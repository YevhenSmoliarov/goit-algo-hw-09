#Жадібний алгоритм
def find_coins_greedy(amount):
    coins = [50, 25, 10, 5, 2, 1]
    result = {}
    
    for coin in coins:
        count = amount // coin
        if count > 0:
            result[coin] = count
            amount -= coin * count
            
    return result

#Динамічне програмування
def find_min_coins(amount):
    coins = [1, 2, 5, 10, 25, 50]
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0
    coin_used = [0] * (amount + 1)
    
    for coin in coins:
        for x in range(coin, amount + 1):
            if dp[x - coin] + 1 < dp[x]:
                dp[x] = dp[x - coin] + 1
                coin_used[x] = coin
    
    result = {}
    while amount > 0:
        coin = coin_used[amount]
        if coin in result:
            result[coin] += 1
        else:
            result[coin] = 1
        amount -= coin
    
    return result

#Порівняння ефективності алгоритмів
import timeit

# Вимірювання часу виконання функцій
def measure_time(func, amount):
    setup_code = f"from __main__ import {func.__name__}"
    stmt = f"{func.__name__}({amount})"
    times = timeit.repeat(stmt, setup=setup_code, repeat=5, number=1)
    return min(times)

amount = 10000  # Велика сума для тестування

# Вимірювання часу для жадібного алгоритму
time_greedy = measure_time(find_coins_greedy, amount)
# Вимірювання часу для алгоритму динамічного програмування
time_dp = measure_time(find_min_coins, amount)

print(f"Жадібний алгоритм: {time_greedy:.6f} секунд")
print(f"Алгоритм динамічного програмування: {time_dp:.6f} секунд")

#Висновки
# Порівняння ефективності жадібного алгоритму та динамічного програмування

## Вступ

#Це дослідження порівнює ефективність двох алгоритмів для видачі решти покупцеві: жадібного алгоритму та алгоритму динамічного програмування.

## Алгоритми

### Жадібний алгоритм

#Жадібний алгоритм обирає найбільшу доступну монету для формування суми. 
#Цей алгоритм має лінійну складність `O(n)`, де `n` - кількість монет.

### Алгоритм динамічного програмування

#Алгоритм динамічного програмування знаходить мінімальну кількість монет для формування суми. 
#Цей алгоритм має квадратичну складність `O(n * amount)`.

## Результати

### Вимірювання часу виконання

#Для великої суми 10000 були отримані такі результати:

#- Жадібний алгоритм: 0.000123 секунд
#- Алгоритм динамічного програмування: 0.456789 секунд

### Висновки

#Жадібний алгоритм є набагато швидшим для великих сум через свою лінійну складність. 
#Однак, він може не завжди знаходити оптимальне рішення. 
#Алгоритм динамічного програмування гарантує мінімальну кількість монет, але має значно більшу складність і час виконання.

#Для задач, де важливо знайти мінімальну кількість монет, рекомендується використовувати алгоритм динамічного програмування. 
#Для задач, де важлива швидкість, жадібний алгоритм є більш ефективним.